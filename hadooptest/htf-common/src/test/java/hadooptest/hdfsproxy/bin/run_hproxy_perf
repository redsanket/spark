#!/usr/bin/env perl 

# HDFS Proxy Performance Test
# Takes parameters of 1) cluster, 2) hdfsproxy host, 3) total data payload, and 4) number of threads per host
# The test will run:
# 1. Get the cluster hosts from the specified clusters
# 2. Run load / performance tests on each hosts as forked processes and wait for them to finish.
#    A) The top level script run_hproxy_perf will call the script
#       run_hproxy_perf_single_host for each host in the cluster
#    B) The run_hproxy_perf_single_host script will then call the script
#       run_hproxy_perf_single_thread for each of the specified number of threads
#    C) Each thread will then issue a curl command with op=create
#       E.g. curl -s \
#            -b /tmp/hdfsproxy_perf_hadoopqa/cookies.txt \
#            --negotiate -u: -k -T "/grid/0/tmp/file-64M" \
#            "https://gsbl90063.blue.ygrid.yahoo.com:4443/fs/tmp/file-64M-gsbl90321-thread-14-1?op=create"
# 3. When all the forked threads are finished, fetch and grapch the
#    kbps in and out from ysar after the payload transfer has completed.
#
# Example Usage:
# run_hproxy_perf -cluster <cluster> -payload_size <payload size> -payload_unit=<payload unit> -threads_per_host=<num threads>
# run_hproxy_perf -cluster sam -payload_size=500 -payload_unit=G -threads_per_host=16
#
# Requires:
# yinst i ypan/perl-Data-Dumper-2.139_05
# yinst i ypan/perl-JSON-2.90_148
# yinst i ypan/perl-Math-Round
# yinst i ypan/perl-Text-Trim
# yinst i ypan/perl-XML-XML2JSON
# yinst i ysar
# yinst set ysar.gather_freq=1; yinst restart ycron

use strict;
use warnings;
use FindBin qw($Bin $Script);
use Test::More;
use File::Copy;
use File::Basename;

sub usage {
    my ($err_msg) = @_;
    print "Usage: $Script -c <cluster> -p <proxy> -l <total payload> <option1> <values1> <option2> <values2> ...";
    die($err_msg) if ($err_msg);
    exit 0;
}

# PARAM
my %options=();
my $cmd;
my $cluster='sam';

my $hproxy;
my $hproxy_http="false";
my $client_hosts;
my $payload_size = "500";
my $payload_unit = "G";
my $threads_per_host=16;
my $file_size="64";
my $file_unit="M";
my $rc;

my $username = getpwuid( $< );
my $tmpdir = "/tmp/hdfsproxy_perf_$username";
execute("rm -rf $tmpdir");
execute("mkdir -p $tmpdir");

#
# Command line options processing
#
use Getopt::Long;
&Getopt::Long::Configure( 'pass_through');
my $result = 
GetOptions(\%options,
    "client_hosts|i=s"     => \$client_hosts,
    "hproxy_http|l=s"      => \$hproxy_http,
    "cluster|c=s"          => \$cluster,
    "proxy|x=s"            => \$hproxy,
    "payload_size|p=s"     => \$payload_size,
    "payload_unit|u=s"     => \$payload_unit,
    "file_size|f=s"        => \$file_size,
    "file_unit|n=s"        => \$file_unit,
    "threads_per_host|t=s" => \$threads_per_host,
    "help|h|?"
    ) or usage(1);
usage() if $options{help};
usage("Invalid arguments!!!") if (!$result);
usage("ERROR: Required cluster value not defined!!!") if (!defined($cluster));

# Setup prerequisite ypan packages
BEGIN {
    print("Setup yinst ypan packages\n");
    system("yinst i -yes ysar ypan/perl-Data-Dumper ypan/perl-JSON ypan/perl-Math-Round ypan/perl-Text-Trim ypan/perl-XML-XML2JSON");
    system("yinst set ysar.gather_freq=1");
}

use Data::Dumper;
use JSON qw( decode_json );
use Math::Round;
use Text::Trim;
use XML::XML2JSON;

chomp(my $hostname=`hostname`);

# If hproxy is not defined or has the value 'default', then fetch the proxy host
# value from the rolesdb role for the cluster
# $hproxy="gsbl90600.blue.ygrid.yahoo.com";
if ((!defined($hproxy)) || ($hproxy eq "default")) {
    trim($hproxy = `yinst range -ir "(\@grid_re.clusters.$cluster.hdfsproxy)"`);
}

note("Running on host '$hostname', using hdfsproxy '$hproxy' ");

# trim(my $nn_alias = `yinst range -ir "(\@grid_re.clusters.$cluster.namenode_alias)"`);

execute("ssh -t adm102.blue.ygrid.yahoo.com sudo ssh -t $hproxy chmod a+r /home/y/conf/yjava_tomcat/ssl.crt/ca.crt /home/y/conf/ygrid_services_cert/ca.crt");
execute("ssh -t adm102.blue.ygrid.yahoo.com sudo ssh -t $hproxy ls -l /home/y/conf/yjava_tomcat/ssl.crt/ca.crt /home/y/conf/ygrid_services_cert/ca.crt");

# execute("scp $hproxy:/grid/0/yroot/var/yroots/hit_hp/home/y/conf/yjava_tomcat/ssl.crt/ca.crt $tmpdir/ca.crt");
execute("scp $hproxy:/home/y/conf/yjava_tomcat/ssl.crt/ca.crt $tmpdir/ca.crt");

note("cluster='$cluster'");
note("hdfsproxy server='$hproxy'");

#################################################################################
# Check if the namenode_address setting on the hdfsproxy host need to be set
# to the current cluster namenode under test.
#################################################################################
echo "Check if the namenode_address is properly set on the hdfsproxy host '$hproxy':"
NN=`yinst range -ir "(@grid_re.clusters.$cluster.namenode)"`
expected_namenode_address="hdfs://$NN:8020"
current_namenode_address=`ssh $hproxy yinst set ygrid_hdfsproxy.namenode_address | cut -d' ' -f2`
if [[ "$current_namenode_address" != "$expected_namenode_address" ]]; then
    set -x
    ssh $hproxy "yinst set ygrid_hdfsproxy.namenode_address=hdfs://$NN:8020"
    ssh $hproxy "yinst stop ygrid_hdfsproxy"
    ssh $hproxy "yinst start ygrid_hdfsproxy"
    set +x
fi

#################################################################################
# Clean up target dir/files
#################################################################################
note("Delete any pre-existing target files:");
$cmd = "kinit -kt ~/hadoopqa.dev.headless.keytab hadoopqa";
execute($cmd);
my $target_dir="fs/tmp";
my $file_prefix="file-".$file_size.$file_unit;
my $target_files = "$target_dir/$file_prefix"."*";

$cmd  = "/home/gs/gridre/yroot.$cluster/share/hadoop/bin/hadoop ";
$cmd .= "--config /home/gs/gridre/yroot.$cluster/conf/hadoop/ ";
$cmd .= "fs -rm /tmp/$file_prefix*";
$rc = execute($cmd);
note("Delete any pre-existing target files: status '$rc'");

#################################################################################
# 1. Get the hosts for the cluster under test
#################################################################################
my @hosts;
if ((!defined($client_hosts)) || ($client_hosts eq "default")) {
    @hosts=split("\n", `yinst range -ir "(\@grid_re.clusters.$cluster,-\@grid_re.clusters.$cluster.namenode,-\@grid_re.clusters.$cluster.namenode2,-\@grid_re.clusters.$cluster.hdfsproxy)"`);
} 
else {
    @hosts=split(",", $client_hosts);
}
note("hosts='".join(",",@hosts)."'");
my $num_hosts=scalar(@hosts);
# note("Number of hosts='$num_hosts'");

# PARAM
# my $payload_per_host = round($payload_size/$num_hosts);
my $payload_per_host = nearest(0.01, $payload_size/$num_hosts);
#note("Payload per host='$payload_per_host$payload_unit'");
note("(Total payload='$payload_size$payload_unit')/(Number of hosts='$num_hosts')=(Payload per host='$payload_per_host$payload_unit')");

# my $payload_mb_per_host = round(convert_to_mb($payload_size, $payload_unit)/$num_hosts);
# note("Payload per host='$payload_mb_per_host"."M'");

# note("Number of threads per host='$threads_per_host'");
# my $payload_per_thread = round($payload_per_host/$threads_per_host);
my $payload_per_thread = nearest(0.01, $payload_per_host/$threads_per_host);
# note("Payload per host thread='$payload_per_thread$payload_unit'");
note("(Payload per host='$payload_per_host$payload_unit')/(Number of threads per host='$threads_per_host')=(Payload per host thread='$payload_per_thread$payload_unit')");

# note("Number of threads per host='$threads_per_host'");
# my $payload_mb_per_thread = round($payload_mb_per_host/$threads_per_host);
# note("Payload per host thread='$payload_mb_per_thread"."M'");

# PARAM
# 104857600
# note("File size='$file_size$file_unit'");

#$max=(convert_to_byte($payload_size, $payload_unit) / convert_to_byte($file_size, $file_unit));
# my $num_iterate=round($payload_mb_per_thread/convert_to_mb($file_size,$file_unit));
# note("Number of iterations per thread='$num_iterate'");

# note("'num_iterate=round(convert_to_mb($payload_per_thread,$payload_unit)/convert_to_mb($file_size,$file_unit))'");
my $num_iterate=round(convert_to_mb($payload_per_thread,$payload_unit)/convert_to_mb($file_size,$file_unit));
#note("Number of iterations per thread='$num_iterate'");
note("(Payload per host thread='$payload_per_thread$payload_unit')/(File size='$file_size$file_unit')=(Number of iterations per thread='$num_iterate')");
if ($num_iterate < 1) {
    die("Number of iteration for file create cannot be less than 1!!!");
}

# debug
# exit;

#################################################################################
# 2. Run load / performance tests on each hosts as a forked process
#################################################################################
trim(my $start_time=`date +%s`);
note("start_time='$start_time'");

my $remote_test_script="run_hproxy_perf_single_host";
my $remote_test_script2="run_hproxy_perf_single_thread";
my $host_index=1;
my $host_id;

use POSIX ":sys_wait_h";
my @pids;

for my $host (@hosts) {
    $host_id="host-$host_index/$num_hosts $host";
    # http://perldoc.perl.org/functions/fork.html
    my $pid = fork();
    if ($pid == 0) {
        # forked child process has pid of 0
        logger("----> Forked Child Process #$host_index to $host_id: Started");
        $rc = run_threads_on_single_host($host_index, $host);
        logger("----> Forked Child Process #$host_index to $host_id: Finished: rc='$rc'");
        exit($rc);
    } else {
        # parent process has non zero pid
        logger("--> Forked Child Process #$host_index PID=$pid to $host_id:");
        $pids[($host_index-1)] = $pid;
    }
    $host_index++;
    # debug
    # exit;
}

#################################################################################
# 2. Wait for forked processes to finish
#################################################################################
logger("--> Wait for ".scalar(@pids)." Child Processes [".join(",", @pids)."] ".
       "running on $num_hosts hosts to finish:");
my $keep_waiting;
do {
    $keep_waiting = 0;
    # Check all PID not yet completed (i.e. non zero)
    for my $num_host (1..$num_hosts) {
        my $i = ($num_host-1);
        if ($pids[$i] > 0) {
            if (waitpid($pids[$i], WNOHANG) != 0) {
                logger("----> Forked Child Process #$num_host to $host_id: PID $pids[$i] completed.");
                $pids[$i] = 0;
            } else {
                # logger("Waiting on Forked Child Process #$num_host: PID $pids[$i]");
                $keep_waiting = 1;
            }
        }
        # Give up timeslice and prevent hard loop: this may not work on all flavors of Unix
        sleep(0);
    }
} while ($keep_waiting);


#################################################################################
# Audit
#################################################################################
# $cmd  = "kinit -kt ~hitusr_1/hitusr_1.dev.headless.keytab hitusr_1\@DEV.YGRID.YAHOO.COM";
$cmd = "kinit -kt ~/hadoopqa.dev.headless.keytab hadoopqa";
execute($cmd);

$cmd  = "/home/gs/gridre/yroot.$cluster/share/hadoop/bin/hadoop ";
$cmd .= "--config /home/gs/gridre/yroot.$cluster/conf/hadoop/ ";
$cmd .= "fs -ls /tmp/$file_prefix*";
$cmd .= "|sort -t '-' -k13,13n";
note("cmd='$cmd'");
my $xml_status=`$cmd`;
note("output='$xml_status'");


my $ysar_interval=1;
my $ysar="/home/y/bin/ysar";
$ysar .= " -interval $ysar_interval";
# $ysar .= " -f /grid/0/yroot/var/yroots/hit_hp/home/y/logs/ysar/ysar.dat -Summary";

$cmd="ssh $hproxy $ysar";
note($cmd);
my $ysar_output=`$cmd`;
note("ysar out='$ysar_output'");

#################################################################################
# 3. Determine the in and out kbps after the payload transfer has completed.
#################################################################################
note("#################################################################################");
note("Determine the in and out kbps after the playload transfer of ".
     "'$payload_size$payload_unit' has completed");
note("(hosts='$num_hosts', threads_per_host='$threads_per_host', ".
     "iteration_per_thread='$num_iterate', file_size='$file_size$file_unit').");
note("#################################################################################");

#################################################################################
# Get start time, end time, time duration, and midpoint time
#################################################################################
use POSIX qw(strftime);
trim(my $end_time=`date +%s`);
note("start_time='$start_time', end_time='$end_time'");
show_time("start_time", $start_time);
show_time("end_time", $end_time);

#################################################################################
# Construct the time string to grep from ysar
#################################################################################

#################################################################################
# Get the ysar output for the specified time, and parse the in and out kbps
# E.g. 09/19-12:00
#################################################################################
$cmd="ssh $hproxy $ysar | awk -v start_time=$start_time -v end_time=$end_time '{
    year=strftime(\"%Y\",systime())
    split(\$1,tokens,\"/\")
    month=tokens[1]
    split(tokens[2],tokens,\"-\")
    day=tokens[1]
    split(tokens[2],tokens,\":\")
    hour=tokens[1]
    min=tokens[2]
    sec=\"00\"
    time=year FS month FS day FS hour FS min FS sec
    timeCand = mktime(time)
    if(timeCand >= start_time && timeCand <= end_time) print \$0

}'
";
note($cmd);
trim($ysar_output = `$cmd`);
note("ysar_out='$ysar_output'");
my $max=0;
my $seek_time;
my $outkbps;
my $inkbps;
my @lines = split("\n", $ysar_output);
foreach my $line( @lines ) {
    my @token = split(" ",$line);
    $outkbps=$token[-1];
    if($outkbps > $max){
        $max = $outkbps;
        $seek_time = $token[0];
        $inkbps = $token[-2];
    }
}
$outkbps=$max;

note("seek_time='$seek_time'");
note("inkbps='$inkbps', outkbps='$outkbps'");

# Plot Data
my $report_dir="$Bin/../../../../../../../htf-common/target/surefire-reports/";
unless (-e $report_dir) {
    `mkdir -p $report_dir`;
}
note("report_dir=$report_dir");
my $filename = "hdfsproxy_perf_plot.txt";
`echo "inkbps,outkbps" > $report_dir/$filename`;
`echo "$inkbps,$outkbps" >> $report_dir/$filename`;
# execute("echo \"inkbps,outkbps\" > $report_dir/$filename");
# execute("echo \"$inkbps,$outkbps\" >> $report_dir/$filename");
execute("ls -l $report_dir/$filename");

#################################################################################
# Clean up target dir/files
#################################################################################
note("Delete target files:");
$cmd = "kinit -kt ~/hadoopqa.dev.headless.keytab hadoopqa";
execute($cmd);

$cmd  = "/home/gs/gridre/yroot.$cluster/share/hadoop/bin/hadoop ";
$cmd .= "--config /home/gs/gridre/yroot.$cluster/conf/hadoop/ ";
$cmd .= "fs -rm /tmp/$file_prefix*";
$rc = execute($cmd);
note("Delete all target files: status '$rc'");


#################################################################################
# SUBROUTINES
#################################################################################

sub execute {
    my ($command) = @_;
    note($command);
    system ($command);
    return $?;
}

sub logger {
    my ($msg) = @_;
    note(scalar localtime(), ": $msg");
}

sub show_time {
  my ($msg, $time) = @_;
  note("$msg='$time'='".strftime("%m/%d-%H:%M", localtime($time))."'");
}

sub convert_to_byte {
  my ($file_size, $file_unit) = @_;
  # my $file_unit=substr($file_size, -1);
  my $byte;
  if ($file_unit eq "M") {
    $byte = $file_size*1024*1024;
  } elsif ($file_unit eq "G") {
    $byte = $file_size*1024*1024*1024;
  } else {
    $byte = $file_size;
  } 
  return $byte;
}

sub convert_to_mb {
  my ($file_size, $file_unit) = @_;
  # my $file_unit=substr($file_size, -1);
  my $mb;
  if ($file_unit eq "M") {
      $mb = $file_size;
  } elsif ($file_unit eq "G") {
    $mb = $file_size*1024;
  } else {
    $mb = $file_size;
  } 
  return $mb;
}

sub run_threads_on_single_host {
    my ($host_index, $host) = @_;
    note("#################################################################################");
    note("ssh to host-$host_index/$num_hosts $host to run hdfs create load testing");
    note("#################################################################################");

    my $cmd="ssh $host \"rm -rf $tmpdir; mkdir -p $tmpdir\"";
    execute($cmd);

    # $cmd="ssh $host rm /tmp/$remote_test_script /tmp/$remote_test_script2 /tmp/ca.crt";
    # execute($cmd);

    $cmd="scp $Bin/$remote_test_script $Bin/$remote_test_script2 $tmpdir/ca.crt $host:$tmpdir";
    execute($cmd);

    $cmd = "ssh -t $host yinst i -yes ypan/perl-JSON ypan/perl-Text-Trim ypan/perl-XML-XML2JSON";
    execute($cmd);

    # $cmd = "ssh $host \"kinit -kt ~hitusr_1/hitusr_1.dev.headless.keytab hitusr_1\@DEV.YGRID.YAHOO.COM\"";
    $cmd = "ssh $host \"kinit -kt ~/hadoopqa.dev.headless.keytab hadoopqa\"";
    execute($cmd);

    # debug 
    # $threads_per_host=2;

    $cmd  = "ssh $host $tmpdir/$remote_test_script";
    $cmd .= " -proxy $hproxy";
    $cmd .= " -hproxy_http $hproxy_http";
    $cmd .= " -thread $threads_per_host";
    $cmd .= " -file_size $file_size -file_unit $file_unit";
    $cmd .= " -host_index $host_index";
    $cmd .= " -num_hosts $num_hosts";
    $cmd .= " -iterate $num_iterate";
    my $rc = execute($cmd);
    return $rc;
}
