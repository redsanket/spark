#!/bin/bash

#################################################################################
# This script is run after a new hadoop core version has passed QE certification.
# It will perform the following tasks:
# 1) Generate the yinst freeze tgz files and copy them to nfs mount on
#    devadm102:/net/adm.ygrid.yahoo.com/home/y/share/adm/pub/Releases/
#    There it will be used by the SE deployment scripts
#    for deploying hadoop to sandbox/research/production clusters.
# 2) Update the hadoop_releases git repo, which is used to managed the package
#    versions for all components and clusters. This script will do the following:
#    2.1) Insert a new bundle yaml fille with the new tgz package versions for core
#       (e.g. $REL_MR_DIR/bundles/hadoop_core/hadoop_core-$TIME.yaml).
#    2.2) Update the clusters.yaml file to promote the new bundle serial number to
#       the specified cluster or clusters. (By default, the cluster promoted will be
#       axonitered)
#################################################################################
# Pre-reqs:
# 1) ADM host should be reachable.
# 2) CFG_NFS_MOUNT directory should be mounted on ADM.
# 3) yroot must be installed on ADM.
# 4) Runs as hadoopqa
# 5) hadoopqa must be sudo no password permission from the ADM host
# 6) anonuid is set to gadmin for nfs export. So any file written will have uid set to gadmin
#################################################################################
# Required packages:
#
# Local (e.g. re107):
#   git
# Remote (e.g. adm102):
#   yroot
#   mtree (rpm version)
#################################################################################

# https://git.corp.yahoo.com/GridSE/hadoop_releases
# git@git.corp.yahoo.com:GridSE/hadoop_releases.git

SCRIPT_DIR=`dirname $(readlink -f $0)`
TIME=`date -u +\%y\%m\%d\%H\%M\%S`
TMP_DIR="/tmp/makerelease.$TIME"
DIST_TAG="/home/y/bin/dist_tag"

set -x
CERTIFIED_TAG=${CERTIFIED_TAG:="hadoop_latest_certified_release"}
packages=${packages:="hadoop conf hadoop_mvn_tools"}
yroot_name=${YROOT_NAME:="make-release"}
CLEAN_YROOT=${CLEAN_YROOT:="false"}
ADM=${ADM_HOST:="devadm102.blue.ygrid.yahoo.com"}
CFG_ADM=${CFG_ADM_HOST:="adm.ygrid.yahoo.com"}
CFG_NFS_MOUNT=${CFG_NFS_MOUNT:="/net/adm.ygrid.yahoo.com/home/y/share/adm/pub/Releases"}
CLUSTERS=${CLUSTERS:="all"}
CLUSTER_ROLES=${CLUSTER_ROLES:="grid.clusters.sandbox,grid.clusters.research"}
CLUSTERS_TO_PROMOTE=${CLUSTERS_TO_PROMOTE:="none"}
COMPONENTS=${COMPONENTS:='hadoop'}
CLEANUP=${CLEANUP:="true"}
set +x

# GIT_REPO="git@git.corp.yahoo.com:GridSE/gridPush.git"
MR_DIR="$TMP_DIR/gridPush"

REL_GIT_REPO="git@git.corp.yahoo.com:GridSE/hadoop_releases.git"
REL_MR_DIR="$TMP_DIR/hadoop_releases"
# REL_GIT_INTERIM_DIR="$TMP_DIR/hadoop_releases/interim_solution"
UPLOAD_RELEASE=${UPLOAD_RELEASE:="false"}

yroot_release_dir="/grid/0/releases"
cfg_release_dir="/pub/Releases"

# OVERRIDE_TAG=${OVERRIDE_TAG:="false"}

################################################################################
# check if ADM is reachable
# check if yroot is installed on ADM
# check if CFG_NFS_MOUNT exist
################################################################################
ssh $ADM "date"
RC=$?
if [[ $RC -ne 0 ]]; then
  echo "Host $ADM is not reachable. CHECK!!!. Exiting"
  exit 1
fi

ssh $ADM "ls /home/y/bin/yroot"
RC=$?
if [[ $RC -ne 0 ]]; then
  echo "Yroot is not installed on $ADM. CHECK!!!. Exiting"
  exit 1
fi

ssh $ADM "sudo su gadmin -c \"ls -ld $CFG_NFS_MOUNT\""
RC=$?
if [[ $RC -ne 0 ]]; then
  echo "Grid SE ADM nfs mount $CFG_NFS_MOUNT doesn't exist. CHECK!!!. Exiting"
  exit 1
fi

################################################################################

HADOOP_VERSION=`$DIST_TAG list $CERTIFIED_TAG|grep coretree|awk '{print $1}'|cut -d - -f2|sed 's/\./_/g'`
if [[ "$CERTIFIED_TAG" == "hadoop_2_8_latest_certified_release" ]]; then
  CERTIFIED_VERSION_TAG="hadoop_certified_$HADOOP_VERSION"
elif [[ "$CERTIFIED_TAG" == "hadoop_latest_certified_release" ]]; then
  CERTIFIED_VERSION_TAG="hadoop_certified_$HADOOP_VERSION"
else
  CERTIFIED_VERSION_TAG=$CERTIFIED_TAG
fi

# # if [[ "$CLUSTERS" == "all" ]]; then
# #   target=`for role in $(echo $CLUSTER_ROLES|tr ',' ' '); do role=$(echo $role|cut -d'.' -f3); echo -n "-$role";done; echo`
# # else
# #   target=`for cluster in $(echo $CLUSTERS|tr ',' '\n'|sort); do echo -n "-";for id in $(echo $cluster | tr '.' '\n' | tr 'a-z' 'A-Z'); do echo -n ${id:0:1}; done; done; echo;`
# # fi
# release_info_dirname="$CERTIFIED_VERSION_TAG-$TIME"
# # release_info_dirpath="$REL_GIT_INTERIM_DIR/$CERTIFIED_VERSION_TAG-$TIME$target"
# release_info_dirpath="$REL_GIT_INTERIM_DIR/$CERTIFIED_VERSION_TAG-$TIME"
set +x

# Clone generic certified tag to version based certified tag.
# If version based certified tag already exists, just use it.
echo "----> Clone generic release tag '$CERTIFIED_TAG' to version based certified tag '$CERTIFIED_VERSION_TAG':"
# Check if the version based certified tag already exists.
if [[ -e /tmp/dist_list_certified_tag ]]; then
   rm /tmp/dist_list_certified_tag
fi
$DIST_TAG list $CERTIFIED_VERSION_TAG --retry 1 2>&1 > /tmp/dist_list_certified_tag
RC=$?
if [[ $RC -eq 0 ]]; then
    echo "WARN: version based certified tag '$CERTIFIED_VERSION_TAG' already exists!!!"
    #
    # Commented out due to issue with dist_tag
    # Error: move from /home/dist/tags/1/hadoop_2_8_0_latest to /home/dist/tags/1/hadoop_2_8_0_latest_171016143456 failed: Is a directory at /home/y/bin/dist_tag line 341.
    #
    # /home/y/bin/dist_tag
    #     File::Copy::move($old_tagdir, $new_tagdir)
    #
    # echo "WARN: rename existing version based certified tag '$CERTIFIED_VERSION_TAG':"
    # set -x
    # $DIST_TAG rename $CERTIFIED_VERSION_TAG $CERTIFIED_VERSION_TAG"_"$TIME
    # set +x
else
    set -x
    $DIST_TAG clone $CERTIFIED_TAG $CERTIFIED_VERSION_TAG
    RC=$?
    set +x
    if [[ $RC -ne 0 ]]; then
        echo "ERROR: dist_tag clone failed!!!"
        exit 1;
    fi
fi


#################################################################################
# Setup remote host yroot
# 1) We must use remote adm hosts because only on it does the headless user hadoopqa
# have sudo access for all without password. This is needed in order to run the
# gridPush makerelease script. 
# 2) We need to run inside a yroot as required by the makerelease script. The
# script will perform a "rm -rf /home/y" among other things. 
#################################################################################
echo "---> Setup yroot '$yroot_name' on the remote host '$ADM':"
if [[ "$CLEAN_YROOT" == "true" ]]; then
  echo "REMOVE EXISTING YROOT if exists:"
  set -x
  # Look for exact match for yroot name
  ssh $ADM "/home/y/bin/yroot --list|grep ${yroot_name}[[:space:]]"
  RC=$?
  set +x
  if [[ $RC -eq 0 ]]; then
    echo "Found yroot '$yroot_name' on remote host '$ADM'."
    set -x
    ssh $ADM "/home/y/bin/yroot --stop $yroot_name"
    ssh $ADM "/home/y/bin/yroot --remove $yroot_name"
    ssh $ADM "/home/y/bin/yroot --list"
    set +x
  fi
fi

set -x
# Look for exact match for yroot name
ssh $ADM "/home/y/bin/yroot --list|grep ${yroot_name}[[:space:]]"
RC=$?
set +x 
if [[ $RC -eq 0 ]]; then
  echo "Found yroot '$yroot_name' on remote host '$ADM'."
  echo "WARN: Remove existing yroot release directory '$yroot_release_dir':"
  set -x
  ssh $ADM "sudo /home/y/bin/yroot $yroot_name --cmd 'rm -rf $yroot_release_dir'"
  set +x
else
  echo "Yroot '$yroot_name' does not exist on remote host '$ADM'."
  echo "Create yroot '$yroot_name' on the remote host '$ADM':"
  set -x
  image=`/home/y/bin/yroot --images|cut -d' ' -f2|grep ^6|tail -1`
  ssh $ADM "/home/y/bin/yroot --create $yroot_name $image"
  set +x
fi

set -x
ssh $ADM "/home/y/bin/yroot --list"
yroot_path=`perl -e 'use Yahoo::Root; print Yahoo::Root->new( name => $ARGV[0] )->realpath("/")."\n";' $yroot_name`
yroot_home=`ssh $ADM "/home/y/bin/yroot $yroot_name --cmd 'pwd'"`
ssh $ADM "sudo /home/y/bin/yroot $yroot_name --cmd 'yinst install ygrid_makerelease -br current -yes'"
RC=$?
set +x
if [[ $RC -ne 0 ]]; then
  echo "Unable to install ygrid_makerelease package on ADM box. CHECK!!!. Exiting"
  exit 1
fi
set -x
ssh $ADM "sudo /home/y/bin/yrootcp /usr/sbin/mtree $yroot_name:/usr/sbin/mtree"
set +x

#################################################################################
# Checkout GridPush from git
#################################################################################
# echo "---> Clone makerelease git repo '$GIT_REPO':"
echo "---> Install ygrid_makerelease pkg"
set -x
mkdir $TMP_DIR
## Replace git repo gridPush with ygrid_makerelease yinst pkg
hostname

## git clone $GIT_REPO $MR_DIR
## ls -ld $MR_DIR
# Scp gridPush git repo to the remote host as it is ACL'd off from the git repo
#scp -r $MR_DIR $ADM:$yroot_path/$yroot_home
set +x

# release_info_file="$release_info_dirpath/hadoop-core.yaml"
# if [[ -d $release_info_dirpath ]]; then
#     echo "WARN: Remove existing directory $release_info_dirpath"
#     rm -rf $release_info_dirpath
# fi
set -x
# mkdir -p $release_info_dirpath
cd $TMP_DIR
set +x

#################################################################################
# Run makerelease on remote host
#################################################################################
echo "--> Generate a a copy of the script that can runs makerelease from inside the yroot on the remote host:"
run_script_file="run_makerelease"
run_script_file_path="$TMP_DIR/$run_script_file"

# E.G. version="2.6.0.9.1503201324"

if [[ "$CLUSTERS" == "all" ]]; then
  set -x
  /home/y/bin/rocl -r $CLUSTER_ROLES -m -G|sort > $TMP_DIR/clusters.all
  /home/y/bin/rocl -r grid.set.clusters_storm -m -G|sort > $TMP_DIR/clusters.storm
  set +x
  # Suppress lines unique to storm cluster and common in both
  CLUSTERS=`/usr/bin/comm -23 $TMP_DIR/clusters.all $TMP_DIR/clusters.storm | awk 'BEGIN {FS="."}{print $1"."$2}'`
  # CLUSTERS='axonite.red'
else
  CLUSTERS=`echo $CLUSTERS|sed 's/,/ /g'`
fi
echo "CLUSTERS='$CLUSTERS'"

# Run makerelease for each cluster

cat > $run_script_file_path << EOF
#!/bin/bash
set -x
pwd
hostname
echo $PATH
sudo mkdir -p $yroot_release_dir
# cd ~/gridPush
EOF

labels=""
YINST_FREEZE_DTS=`date +%Y%m%d-000`
cluster_index=1
for cluster in $CLUSTERS; do
  # TODO: check cluster has the format of <cluster>.<color>
  for package in $packages; do
    if [[ "$cluster_index" -eq 1 ]]; then
      # TODO: replace with: dist_tag list $CLUSTER_CERTIFIED_TAG
      if [[ "$package" == "hadoop" ]]; then
          set -x
          # version=`$DIST_TAG list $CERTIFIED_VERSION_TAG|grep coretree|awk '{print $1}'|cut -d - -f2`
	  version=`cat /tmp/dist_list_certified_tag|grep coretree|awk '{print $1}'|cut -d - -f2`
          set +x
      elif [[ "$package" == "conf" ]]; then
          set -x
          # version=`$DIST_TAG list $CERTIFIED_VERSION_TAG|grep HadoopConfig$(echo $cluster|sed 's/\.//g')|awk '{print $1}'|cut -d - -f2`
	  version=`cat /tmp/dist_list_certified_tag|grep HadoopConfig$(echo $cluster|sed 's/\.//g')|awk '{print $1}'|cut -d - -f2`
          set +x
      elif [[ "$package" == "hadoop_mvn_tools" ]]; then
	  set -x
	  # version=`$DIST_TAG list $CERTIFIED_VERSION_TAG|grep hadoop_mvn_tools|awk '{print $1}'|cut -d - -f2`
	  version=`cat /tmp/dist_list_certified_tag|grep hadoop_mvn_tools|awk '{print $1}'|cut -d - -f2`
	  set +x
      else
          echo "ERROR: invalidate package type '$package' found!!!"
          exit 1;
      fi

      if [[ "$version" == "" ]]; then
        echo "ERROR!!! Unable to find package version for '$package'. Exiting!!!"
        exit 1;
      fi

      # Only update the bundle file once because the packages versions will be
      # the same across clusters
      if [[ -n "$labels" ]]; then
          labels+=","
      fi
      labels+="$package,$version-$YINST_FREEZE_DTS"
      echo "labels='$labels'"
      echo "/usr/local/bin/makerelease -p $package -v $version -c $cluster el6" >> $run_script_file_path
    elif [[ "$package" == "conf" ]]; then
          # version=`$DIST_TAG list $CERTIFIED_VERSION_TAG|grep HadoopConfig$(echo $cluster|sed 's/\.//g')|awk '{print $1}'|cut -d - -f2`
	  version=`cat /tmp/dist_list_certified_tag|grep HadoopConfig$(echo $cluster|sed 's/\.//g')|awk '{print $1}'|cut -d - -f2`
          if [[ "$version" == "" ]]; then
              echo "ERROR!!! Unable to find package version for '$package'. Exiting!!!"
              # this should exit on failure if cluster config packages are missing.
              # exit 1;
          fi
          echo "/usr/local/bin/makerelease -p $package -v $version -c $cluster el6" >> $run_script_file_path
    else
	  # version=`$DIST_TAG list $CERTIFIED_VERSION_TAG|grep hadoop_mvn_tools | awk '{print $1}'|cut -d - -f2`
	  version=`cat /tmp/dist_list_certified_tag|grep hadoop_mvn_tools | awk '{print $1}'|cut -d - -f2`
	  if [[ "$version" == "" ]]; then
	      echo "ERROR!!! Unable to find hadoop_mvn_tools version for '$package'. Exiting!!!"
	      exit 1;
	  fi
	  echo "/usr/local/bin/makerelease -p $package -v $version -c $cluster el6" >> $run_script_file_path
    fi
  done
  cluster_index=$(($cluster_index+1))
done

set -x
hostname
chmod a+x $run_script_file_path
ls -l $run_script_file_path
cat $run_script_file_path
set +x

echo "--> Copy the script to the remote host yroot: $ADM:$yroot_name:"
set -x
ssh $ADM "/home/y/bin/yroot $yroot_name --cmd 'echo \$YROOT_NAME'"
scp $run_script_file_path $ADM:$yroot_path/$yroot_home
ssh $ADM "/home/y/bin/yroot $yroot_name --cmd 'ls -l $yroot_home'"
set +x

echo "--> Execute the script to the remote host yroot: $ADM:$yroot_name:"
set -x
ssh $ADM "/home/y/bin/yroot $yroot_name --cmd '$yroot_home/$run_script_file'"
ssh $ADM "/home/y/bin/yroot $yroot_name --cmd 'ls -l $yroot_release_dir'"
set +x

echo "--> Copy makerelease output tgz files to the grid cfg nfs mount on devadm102:"
if [[ "$UPLOAD_RELEASE" == "true" ]]; then
  # http://twiki.corp.yahoo.com/view/Grid/SupportCFGServer
  # https://docs.google.com/a/yahoo-inc.com/document/d/1uGCgBcBFtvOqmxWJKUI15wX_YRQCivEdzTkChupDZ6w/edit
  # sudo su gadmin -c "scp /tmp/foo adm100.blue.ygrid.yahoo.com:$cfg_release_dir"
  set -x
  # ssh $ADM "sudo su gadmin -c \"scp $yroot_path/$yroot_release_dir/* $CFG_ADM:$cfg_release_dir\""
  ssh $ADM "sudo su gadmin -c \"cp $yroot_path/$yroot_release_dir/* $CFG_NFS_MOUNT\""
  RC=$?
  set +x
  if [[ $RC -ne 0 ]]; then
    echo "Error in copying files from $ADM to $CFG_NFS_MOUNT. CHECK!!!. Exiting"
    exit 1
  fi
  echo "--> Verify makerelease output tgz files are copied to the grid cfg nfs mount:"
  set -x
  files=`ssh $ADM ls $yroot_path/$yroot_release_dir|tr '\n' ' '`
  # ssh $ADM "sudo su gadmin -c \"ssh $CFG_ADM 'cd $cfg_release_dir; ls -l $files'\""
  ssh $ADM "sudo su gadmin -c \"cd $CFG_NFS_MOUNT; ls -l $files\""
  RC=$?
  set +x
  if [[ $RC -ne 0 ]]; then
    echo "Error verifying files copied to $CFG_NFS_MOUNT. CHECK!!!. Exiting"
    exit 1
  fi
else
  echo "UPLOAD_RELEASE=false: Skipping scp makerelease tgz files to '$CFG_NFS_MOUNT'"
fi

# echo "---> Generate the interim release info file:"
# set -x
# cd $REL_GIT_INTERIM_DIR
# set +x
# # - Clusters:
# #       - axonite.red
# #   Packages:
# #       - ...
# #       - ...
# #
# # - Clusters:
# #       - a
# #       - b
# #       - c
# #   Packages:
# #       - ...
# #       - ...
# echo "---" > $release_info_file
# for cluster in $CLUSTERS; do
#   echo "- Clusters:" >> $release_info_file
#   echo "      - $cluster" >> $release_info_file
#   echo "  DistTag:" >> $release_info_file
#   echo "      - "$CERTIFIED_VERSION_TAG >> $release_info_file
#   echo "  Components:" >> $release_info_file
#   for component in $COMPONENTS; do
#     echo "      - $component" >> $release_info_file
#   done
#   echo "  Packages:" >> $release_info_file
#   set -x
#   cluster_id=`echo $cluster|sed 's/\./-/g'`
#   ssh $ADM "ls $yroot_path$yroot_release_dir" | grep 'conf-'$cluster_id | awk ' { print "      - "$1 }' >> $release_info_file
#   ssh $ADM "ls $yroot_path$yroot_release_dir" | grep -v 'conf-' | awk ' { print "      - "$1 }' >> $release_info_file
#   cat $release_info_file
#
#   latest_certified_cluster_filename="hadoop_latest_certified_$cluster_id"
#   latest_certified_cluster_filepath="$REL_GIT_INTERIM_DIR/$latest_certified_cluster_filename"
#   rm $latest_certified_cluster_filename
#   ln -fs $release_info_dirname $latest_certified_cluster_filename
#   git add $latest_certified_cluster_filepath
#   set +x
# done

# # Generate top level yaml file
# # release_versions_file="$REL_GIT_INTERIM_DIR/hadoop_versions.yaml"
# set -x
# ./gen_versions
# set +x

# echo "--> Upload the interim release info to git repo $REL_GIT_REPO:"
# if [[ -f "$release_info_file" ]]; then
#   echo "Upload release file '$release_info_file':"
#   set -x
#   pwd
#   git status
#   git add $release_info_file
#   # This commit previously commits the interim bundle to the interim sub
#   # directory. Since we are transitioning to use the official bundle system
#   # in the directory above, this commit is for now replaced by the commit
#   # that will take place at the root of git repo. Eventually, all the interim
#   # related lines will be removed.
#   # git commit -a -m "Add latest release info yaml file."
#   set +x
#   if [[ "$UPLOAD_RELEASE" == "true" ]]; then
#       set -x
#       git push origin master
#       set +x
#   else
#       echo "UPLOAD_RELEASE=false: Skipping git push"
#   fi
# fi

if [[ "$CLUSTERS_TO_PROMOTE" == "none" ]]; then
  echo "CLUSTERS_TO_PROMOTE is set to none. Nothing to promote. Exiting..."
  exit
fi

if [[ "$UPLOAD_RELEASE" == "true" ]]; then
  echo "UPLOAD_RELEASE=true: Proceed to update the hadoop_releases git repo"
  BUNDLE_SERIAL=`date -u +\%Y\%m\%d\%H\%M\%S`

  # Update the clusters yaml file
  set -x
  $SCRIPT_DIR/insert_bundle_yaml hadoop_core $BUNDLE_SERIAL $labels
  RC=$?
  set +x
  if [[ $RC -ne 0 ]]; then
    echo "Error inserting bundle hadoop_core $BUNDLE_SERIAL $labels. Exiting"
    exit 1
  fi

  # Update the clusters yaml file
  set -x
  $SCRIPT_DIR/update_clusters_yaml hadoop_core $BUNDLE_SERIAL $CLUSTERS_TO_PROMOTE
  RC=$?
  set +x
  if [[ $RC -ne 0 ]]; then
    echo "Error updating clusters_yaml for hadoop_core $BUNDLE_SERIAL $CLUSTERS_TO_PROMOTE. Exiting"
    exit 1
  fi
else
  echo "UPLOAD_RELEASE=false: Skipping updating hadoop_releases git repo"
fi

# Cleanup 
echo "---> Cleanup tmp directory and files:"
if [[ "$CLEANUP" == "true" ]]; then
  set -x
  rm -rf $TMP_DIR
  set +x
fi

exit;


